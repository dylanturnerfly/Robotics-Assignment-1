# Computational Robotics
# Component 4
# Dylan Turner & Noor Hasan

import numpy as np
import numpy.linalg 
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import random
import math


############################################################
#                   Movement of an Arm                     #
############################################################


#Using the same environment as before, implement the 2-joint, 2-link arm in figure 1 arm using
#boxes as the geometries of individual links. Here are more details regarding your robotic arm:

#   • The first link has length 2 and the second has lenght 1.5.
#   • All frames associated with links {Li} are at the center of the boxes. The frames associated ith joints {Ji}are located at the box’s bottom.

#To implement your arm, define the coordinate frame of each link and the relative poses with
#each other. Start with only the first link and its transformations before moving to the second link

# Input: start configuration q0 = (θ0,θ1) and goal configuration qG. Output
# a path (sequence of poses) that start at q0 and ends in qG.
def interpolate_arm(start, goal):
    return 1

#Input: start pose q0 ∈SE(2) and a Plan ( a sequence of N tuples
# (velocity, duration)) that is applied to the start pose and results in a path of N+ 1 states.
def forward_propagate_arm(start_pose, plan):
    return 1

#Input: A path to visualize. Your visualization must include the path
# and an animation of the robot’s movement.
def visualize_arm_path(path):
    return 1

#TODO: In your report include and analyze any design choice of your implementation. Include visual-
# izations of the paths generated by both methods. Submit an example animation (gif is prefered
# but can also be a small mp4).